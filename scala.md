---
number headings: auto, first-level 1, max 6, 1.1
---

```table-of-contents
style: nestedList # TOC style (nestedList|inlineFirstLevel)
maxLevel: 0 # Include headings up to the speficied level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```

# 1 Functional Programming

- based on a premise that we construct only *pure functions*
	- have no *side effects*
		- have no observable effects on the execution of the program aside from computing a result from its inputs
	- *referential transparency* (RT)
		- property of expressions in general
		- expression is referentially transparent if in any program, the expression can be replaced by its result without changing the meaning of the program
		- function is pure if calling it with RT arguments is also RT 
		- RT forces an invariant that everything a function does is represented by the value it returns

## 1.1 Example of referential transparency

```scala
scala> val x = "Hello, World"
x: java.lang.String = Hello, World
 
scala> val r1 = x.reverse
r1: String = dlroW ,olleH
 
scala> val r2 = x.reverse     
r2: String = dlroW ,olleH
```

`r1` and `r2` are the same. Moreover, if we `x` in both for the `x`'s value, we get the same result. I.e. the RT holds.

```scala
scala> val r1 = "Hello, World".reverse
r1: String = dlroW ,olleH
 
scala> val r2 = "Hello, World".reverse
r2: String = dlroW ,olleH
```

## 1.2 Example of breaking of referential transparency

```scala
scala> val x = new StringBuilder("Hello")
x: java.lang.StringBuilder = Hello
 
scala> val y = x.append(", World")
y: java.lang.StringBuilder = Hello, World
 
scala> val r1 = y.toString
r1: java.lang.String = Hello, World
 
scala> val r2 = y.toString
r2: java.lang.String = Hello, World
```

`r1` and `r2` are the same. However, substituting `y` into their respective expressions breaks the RT since `StringBuilder.append` has side effects.

```scala
scala> val x = new StringBuilder("Hello")
x: java.lang.StringBuilder = Hello
 
scala> val r1 = x.append(", World").toString
r1: java.lang.String = Hello, World
 
scala> val r2 = x.append(", World").toString
r2: java.lang.String = Hello, World, World
```

# 2 Environment setup

- `scalac` - compiler
- `scala` - REPL
- `scala-cli` - CLI utility to compile, run, test, package the code and much more
- `sbt`, `sbtn` - build tool
	- `sbt new scala/scala3.g8` - create new Scala 3 project
	- run `sbt` in the directory with `build.sbt` to open up the sbt console
		- `~run` to run the project
		- `~` is optional and causes sbt to re-run the project on file edit/save
		- `exit` or `Ctrl-D` to exit sbt
- `amm` - Ammonite REPL
- `scalafmt` - code formatter

## 2.1 scala-cli

### 2.1.1 run

Code is automatically compiled before running.

**Note:** `scala-cli …` defaults to `scala-cli run …`.

- `scala-cli app.sc`
	- runs the Scala script
	- `.sc` are Scala scripts whereas `.scala` are regular Scala files
		- however, this distinction is merely a convention
- `scala-cli app.sc -- first-arg second-arg`
- `scala-cli <scala files>`
	- runs the given Scala files.
	- a more sensible approach is to give it the whole directory
		- the most common usage is: `scala-cli .`
- `scala-cli Hello.scala hi.sc --main-class hi_sc`
	- useful if the programs have multiple main classes

You can also add source files with the using directive `//> using file`:

```scala
// Main.scala
//> using file Utils.scala  
  
object Main extends App {  
	println(Utils.message)  
}
```

```scala
// Utils.scala

object Utils {  
	val message = "Hello World"  
}
```

Running `scala-cli Main.scala` works just fine. Scala CLI takes into consideration the using directive. There is no need to specify `Utils.scala` as a CLI argument.

- `scala-cli run Hello.scala --watch`
	- watches for changes and re-compiles

### 2.1.2 compile

Since most of the commands automatically compile the code, `scala-cli compile` is useful to check whether the code actually compiles.

### 2.1.3 repl

`scala-cli repl` starts the Scala REPL which lets you interactively run the code and inspect its results.

`repl` accepts the same arguments as `compile`. The code is compiled first and then exposed along with provided dependencies to the REPL session.

### 2.1.4 fmt

Uses `scalafmt` under the hood.

### 2.1.5 clean

Cleans all of the files generated by Scala CLI. 

# 3 Basics

## 3.1 Types

Scala recognises value and reference types:

- value types:
	- Double, Float, Long, Int, Short, Byte, Unit, Boolean, Char
	- subtypes of `AnyVal`
- reference types:
	- List, Option, \<Class>
	- subtypes of `AnyRef`

Both `AnyVal` and `AnyRef` are subtypes of `Any`. `Null` is the subtype of reference types and its only value is `null`. `Nothing` is subtype of all types (the so-called bottom type).

## 3.2 Functions



## 3.3 Object

An `object` is a class that has exactly one instance (i.e. a singleton). It is created lazily when it is referenced, like a lazy val. The definition of an object looks like a class but uses an `object` keyword.

**Note**: Scala has no equivalent to Java's `static` keyword and `object` is often used in Scala where you might use a class with static members in Java.

### 3.3.1 Companion objects

An object with the same name as a class is called a *companion object*. Conversely, the class is the object’s companion class. A companion class or object can access the private members of its companion. Use a companion object for methods and values which are not specific to instances of the companion class.

```scala
import scala.math.{Pi, pow}

case class Circle(radius: Double): 
	import Circle.*
	def area: Double = calculateArea(radius)
	
object Circle:
	private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
	
val circle1 = Circle(5.0)
circle1.area
```

## 3.4 Tail recursion

A call is said to be in *tail position* if the caller does nothing but return the value of the recursive call. If all recursive calls are in tail position, Scala (and many other languages) compiles the recursion into iterative loops that don't consume stack frames for each loop.

`rec(n - 1, n * acc)` is in tail position whereas `1 + rec(n - 1, n * acc)` is not anymore.

We can annotate the recursive function by `@annotation.tailrec` if we expect the function to be tail call optimisable and an error should be thrown otherwise.

# 4 Sources

[Functional Programming in Scala, Second Edition](https://www.manning.com/books/functional-programming-in-scala-second-edition)
[Scala docs | Getting Started](https://docs.scala-lang.org/getting-started/index.html)
[Scala CLI | Overview](https://scala-cli.virtuslab.org/docs/overview)
